%%%% Small single column format
\documentclass[anonymous=false, %
               format=acmsmall, %
               review=true, %
               screen=true, %
               nonacm=true]{acmart}

\usepackage[ruled]{algorithm2e} 
%\usepackage{parskip}
\usepackage{backnaur}
\usepackage{jlcode}
\usepackage{todonotes}
\usepackage{textalpha}

\urlstyle{tt}
\citestyle{acmauthoryear}

\begin{document}

\title{Soss}
%  \titlenote{This is a titlenote}
%  \subtitle{This is a subtitle}
%  \subtitlenote{Subtitle note}

\author{Chad Scherrer}
\orcid{0000-0002-1490-0304}
\affiliation{%
  \institution{RelationalAI}
  % \department{Department of Brain and Cognitive Sciences}
  %\streetaddress{43 Vassar St}
  %\city{Cambridge}
  %\state{MA}
  %\postcode{02139}
  %\country{USA}
}
\email{chad.scherrer@gmail.com}

\author{Taine Zhao}
%\orcid{1234-5678-9012-3456}
\affiliation{%
  \institution{University of Tsukuba}
  \department{Department of Computer Science}
  %\streetaddress{625 Mt Auburn St #3}
  %\city{Cambridge}
  %\state{MA}
  %\postcode{02138}
  %\country{USA}
}
% \email{apfeffer@cra.com}
%\renewcommand\shortauthors{Mage, M. et al}

\begin{abstract}
We present Soss, a probabilistic programming language embedded in the Julia language. Soss represents statistical models in terms of abstract syntax trees, and uses staged compilation for on-demand generation of ``inference primitives'' (random sampling, log-density, etc) without requiring casual users to worry about such details.

The approach taken by Soss makes it easy to extend to take advantage of other packages in the rapidly-growing Julia ecosystem. At the time of this writing, Soss users can choose from several inference back-ends and connect easily with larger systems SymPy and Gen.
\end{abstract}

\maketitle

\section{Introduction}

There are many approaches to building a Probabilistic Programming Language (``PPL''). Soss is distinct from most in a number of ways...

Here's some example code. Lots of dead space on the right, maybe want to try to keep code in a multi-column figure

\begin{lstlisting}[language = Julia]
m = @model n begin
    x ~ Normal(0,10) |> iid(n)
    α ~ Normal()
    β ~ Normal()
    σ ~ HalfNormal()
    yhat = α .+ β .* x
    y ~ For(n) do j 
            Normal(yhat[j],σ)
        end
end
\end{lstlisting} 
  
\section{Model syntax}

 

\section{Model Transformations}

\subsection{Markov Blankets}

\subsection{Conditional Predictive models}




\subsection{Causal Interventions (``Do'' operator)}

\section{Symbolic Manipulation}

\subsection{Symbolic Log-density}

\[
  \ell =
  - 0.5 α^{2} 
  - 0.5 β^{2}
  - σ^{2} 
  + \sum_{\left(j_{1}\right)=1}^{n} \left(- \log{\left(\sigma \right)} 
  - \frac{\log{\left(\pi \right)}}{2} 
  - \frac{\log{\left(2 \right)}}{2} 
  - \frac{\left({y}_{\left(j_{1}\right)} 
  - {\hat{y}}_{\left(j_{1}\right)}\right)^{2}}{2 \sigma^{2}}\right) 
  + \sum_{j_{1}=1}^{n} \left(- 0.005 {x}_{j_{1}}^{2} 
  - 2.99573227355399 
  - \frac{\log{\left(\pi \right)}}{2} 
  + \frac{\log{\left(2 \right)}}{2}\right) 
  - 2 \log{\left(\pi \right)} 
  - 1.38629436111989
\]


\[
  \ell =
  - 3.7 
  - 4.1 n 
  - \frac{ \alpha^{2} }{2}
  - \frac{\beta^2}{2}
  - \sigma^{2} 
  - n \log{\left(\sigma \right)} 
  - 0.005 \sum_{j_{1}=1}^{n} {x}_{j_{1}}^{2} 
  - \frac{1}{\sigma^2}\sum_{j_{1}=1}^{n} \left({y}_{j_{1}} 
  - {\hat{y}}_{j_{1}}\right)^{2}
\]

\subsection{Code Generation}

\section{Implementation}

\begin{lstlisting}[language=julia]
struct Model{A,B,M} 
    args  :: Vector{Symbol}
    vals  :: NamedTuple
    dists :: NamedTuple
    retn  :: Union{Nothing, Symbol, Expr}
end
\end{lstlisting}


\section{Performance}

\todo[inline]{Let's implement models from \url{https://statisticalrethinkingjulia.github.io/MCMCBenchmarks.jl/latest/benchmarks/} for benchmark comparisons}

\todo[inline]{Can Soss really generate arbitrary code?}

The ability to generate arbitrary  Julia code makes it difficult to measure performance in Soss. When a performance bottleneck is found, developers or users can ask Soss to generate something different. This design places no a priori constraints on performance.


\section{Extending Soss}

\section{Related Work}

The idea of code generation and symbolic simplification in an embedded PPL goes back to \emph{Passage} \cite{Scherrer2012}. 

\emph{Hakaru} \cite{narayanan2016probabilistic} takes a more ambitious symbolic approach in a stand-alone PPL, allowing a wider variety of program transformations. 

Soss began with a goal of representing models with continuous, fixed-dimensionality parameter spaces, inspired by \emph{Stan} \cite{stan:2017}.

\emph{Gen} \cite{Cusumano-Towner:2019} was developed independently from Soss, but takes a similar approach (and distinct from most PPLs) in its representation of a model as a function from its arguments to a "trace" (to use Gen's terminology). In both Soss and Gen's static DSL, this trace is a mapping from variable names to values. The similarity of these systems makes interoperability relatively straightforward, as demonstrated in \emph{SossGen} (\url{https://github.com/cscherrer/SossGen.jl}).

\emph{Turing} \cite{ge2018t}

\begin{acks}
We would like to acknowledge...
\end{acks}

\bibliographystyle{acm-reference-format}
\bibliography{ref}

\appendix

\section{Model Syntax}

\begin{figure}[!t]
  \centering
  %\fbox{\rule[-.5cm]{0cm}{\linedwid} \rule[-.5cm]{4cm}{0cm}}
  % using the backnaur package
\begin{bnf*}
  \bnfprod{model}{\bnfts{@model} \bnfsp \bnfpn{args} \bnfsp \bnfts{begin} \bnfsp \bnfpn{statements} \bnfsp \bnfts{end}}\\
  \bnfprod{args}{\bnfes \bnfor \bnfpn{Symbol} \bnfor \bnfpn{Symbol} \bnfts{,} \bnfpn{args}} \\
  \bnfprod{statements}{\bnfpn{statement} \bnfor \bnfpn{statement} \bnfsp \bnftd{Julia Line Sep} \bnfsp \bnfpn{statements} \bnfor \bnfpn{statements} \bnfsp \bnfpn{retn}} \\ 
  \bnfprod{statement}{\bnfpn{assign} \bnfor \bnfpn{sample}} \\
  \bnfprod{assign}{\bnfpn{Symbol} \bnfsp \bnfts{=} \bnfsp \bnfpn{Expr}} \\
  \bnfprod{sample}{\bnfpn{Symbol} \bnfsp \bnfts{\textasciitilde}} \bnfsp \bnfpn{Measure} \\
  \bnfprod{retn}{\bnfts{return} \bnfsp \bnfpn{Expr}} \\
  \bnfprod{Symbol}{\bnftd{Julia Symbol}} \\ 
  \bnfprod{Expr}{\bnftd{Julia Expr}} \\
  \bnfprod{Measure}{\bnftd{Probability measure (see text)}}
\end{bnf*}
  \caption{Backus-Naur Form representation for a user-specified model.}
  \label{fig:bnf}
  \Description{Placeholder figure.}
\end{figure}


Authors may provide appendices to accompany their extended abstract submissions. Please note however that reviewers will not be required to comment on material in these appendices.
\end{document}
